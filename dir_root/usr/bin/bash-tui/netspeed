#!/usr/bin/env bash
##

## BASE BRAIN - Get where you're from and who you are.
MYPID=$$
ORIGINAL_DIR="$(pwd)" # This is not a hot air balloon ride..
fa="$0" # First Assumption
ta= # Temporary Assumption
wa= # Weighed Assumption
while true; do
    [ "${fa:0:1}" = "/" ] && wa=$0 && break
    [ "${fa:0:2}" = "./" ] && ta="${ORIGINAL_DIR}/${fa:2}" && [ -e "$ta" ] && wa="$ta" && break
    ta="${ORIGINAL_DIR}/${fa}" && [ -e "$ta" ] && wa="$ta" && break
done
SW="$wa"
SWDIR="$(dirname "$wa")"
SWBIN="$(basename "$wa")"
unset ta fa wa
( [ ! -e "$SWDIR/$SWBIN" ] || [ -z "$SW" ] ) && echo "I could not find my way around :( possible bug in the TOP script" && exit 1

### Libraries

. /etc/profile.d/20_rosterlib.sh
. /usr/lib/bash-tui/bashparms.sh


## If you need help, getHelp
isParm help && _BP_getHelp && exit 113

## TODO how do we log this? how can you log both the line and the value without it looking unreadable?

##
## Tracks speed and traffic for an interface given
## if you don't give me an interface I'll get what I think is default
eth=$(getParm i) || eth=$(ip -4 route list 0/0 | awk '{print $5}' | head -n1) ##BP: Ethernet interface (default: first interface with gateway)
RX=/sys/class/net/$eth/statistics/rx_bytes
TX=/sys/class/net/$eth/statistics/tx_bytes

( [ ! -e ${RX} ] || [ ! -e ${TX} ] ) && say "Make sure $eth is correct..." error && exit 1

### METHODS

### I decided to scale this in 4 sections of 5, 10, 10, 10 dots/dashes/equals.
# -> _netspeed_liner SPEED_Bps 
_netspeed_liner()
{
  [ -z "$1" ] && exit 50
  _speed=$1

  ## 1. 5 slots from 0 to 1mbps = 131.072
  mbps1=131072
  mbps1_slot=$(( mbps1 / 10 ))
  ## 2. 10 slots from 1mbps to 10mbps = 1.310.720
  mbps10=1310720
  mbps10_slot=$(( mbps10 / 10 ))
  mbps10_start=9
  ## 3. 10 slots from 10mbps to 100mbps = 13.107.200
  mbps100=13107200
  mbps100_slot=$(( mbps100 / 10 ))
  mbps100_start=19
  ## 4. 10 slots from 100mbps to 1gbps = 134.217.728
  mbps1000=134217720
  mbps1000_slot=$(( mbps1000 / 10 ))
  mbps1000_start=29
  ## Starting score
  _score=1
  ## Now calculate RX
  while true; do
    (( ! $_speed )) && _score=0 && break

    ## 1 gbps
    if [ $_speed -gt $mbps100 ]; then
      _score=${mbps1000_start}
      for (( m=10; m>0; m--)); do
        (( $(( _speed / ( mbps1000_slot * m ) )) )) && (( _score += m )) && break 2
      done
      (( _score += 11 ))
    ## 100 mbps
    elif [ $_speed -gt $mbps10 ]; then
      _score=${mbps100_start}
      for (( m=10; m>0; m--)); do
        (( $(( _speed / ( mbps100_slot * m ) )) )) && (( _score += m )) && break 2
      done
      (( _score += 10 ))
    ## 10 mbps
    elif [ $_speed -gt $mbps1 ]; then
      _score=${mbps10_start}
      for (( m=10; m>0; m--)); do
        (( $(( _speed / ( mbps10_slot * m ) )) )) && (( _score += m )) && break 2
      done
      (( _score += 10 ))
    ## 1 mbps
    elif [ $_speed -le $mbps1 ]; then
      for (( m=10; m>0; m--)); do
        #say "[$m]doing: $(( _speed / ( mbps1_slot * m ) )) : $_speed / $(( mbps1_slot * m ))"
        (( $(( _speed / ( mbps1_slot * m ) )) )) && (( _score += m )) && break 2
      done
    fi
    break
  done
  echo "${_score}"
}
# -> _netspeed_pretty IT_weight 'T' 1/0
# original value, Array of magnitude (GB, MB etc), Recursive magnitude
_netspeed_pretty()
{
  ## 1024 or 1000...
  kbv=1024 
  declare -A Ss=(
    [G]=$((kbv * kbv * kbv))
    [M]=$((kbv * kbv))
    [K]=${kbv}
    [b]=1
  )
  declare -a So=( G M K b )
  
  ## TIME
  declare -A Ts=(
    [d]=$((60 * 60 * 24))
    [h]=$((60 * 60))
    [m]=60
    [s]=1
  )
  declare -a To=( d h m s )

  # The remainder during the operations
  IT_rest=
  # The final string
  IT_pretty=''
  # The initial value, mandatory
  IT_weight=$1 || return 23
  # The name of the array in which you have the order of magnitude (GB. MB... etc)
  L_name=$2 || 'S'
  # If you want the magnitude to be recursive: 1 (eg. 3G,24M,14K,3b), or if you want to stop at the first occurrence: 0 (eg. 1GB)
  recursive=$3 || recursive=0

  declare -A Ls
  declare -a Lo
  eval "Lo=( \"\${${L_name}o[@]}\" )"

  # yeah I know this is violently convoluted, so what?
  d=0
  for (( c=0; c<${#Lo[@]}; c++ )); do
    Ls[${Lo[$c]}]=$(eval "echo \${${L_name}s[${Lo[$c]}]}")
    IT_tmp=$(( $IT_weight / ${Ls[${Lo[$c]}]} ))
    if (( $IT_tmp )); then 
      (( $d )) && IT_pretty+=','
      IT_pretty+="${IT_tmp}${Lo[$c]}"
      ## if we want to make this recursive...
      ((d++))
      if (( $recursive )); then
        IT_rest=$(( $IT_weight % ${Ls[${Lo[$c]}]} ))
        ## So if we have any rest, we'll rest it
        (( $IT_rest )) && IT_weight=$IT_rest || break
      else
        break
      fi
    fi
  done
  echo "${IT_pretty}"
return 0
}

##### CONF

TIME_start=$(date +%s)

TX_start=$(cat $TX | xargs)
TX_speed=0
TX_pretty=0
TX_weight=0
TX_end=0

RX_start=$(cat $RX | xargs)
TX_speed=0
RX_pretty=0
RX_weight=0
RX_end=0

TIME_pretty=0

sleep 1

## And now let's do some me.. math
echo -e "\nRunning Netspeed against interface: $eth"
tabs 45 
while true; do ((r++))
  RX_weight=$(( $(cat $RX | xargs) - $RX_start ))
  TX_weight=$(( $(cat $TX | xargs) - $TX_start ))
  TIME_weight=$(( $(date +%s) - $TIME_start ))

  RX_speed=$(( $RX_weight - $RX_end ))
  TX_speed=$(( $TX_weight - $TX_end ))

  ## Why end? cause I'm negative..
  RX_end=$RX_weight
  TX_end=$TX_weight

  ## Get the right values
  TIME_pretty=$(_netspeed_pretty ${TIME_weight} T 1)

  RX_pretty=$(_netspeed_pretty ${RX_weight} S 1)
  TX_pretty=$(_netspeed_pretty ${TX_weight} S 1)
  RX_speed_pretty=$(_netspeed_pretty ${RX_speed} S 1)
  TX_speed_pretty=$(_netspeed_pretty ${TX_speed} S 1)

  # This is to reset the line
  echo -ne "                                                                                        \r"
  # This is the output
      
  echo -ne "${dred}RX:${red}$RX_pretty - ${RX_speed_pretty}/s\t"
  echo -ne "${orange}TX:${yellow}$TX_pretty - ${TX_speed_pretty}/s${NC}\t"
  echo -ne "${dgreen}Time:${green}${TIME_pretty}\r"

  ## Measure speed and translate it to dots...
  (( $RX_speed )) && RX_leng=$(printf %0$(_netspeed_liner ${RX_speed})s|tr \  -)
  (( $TX_speed )) && TX_leng=$(printf %0$(_netspeed_liner ${TX_speed})s|tr \  -)
  sleep 1

  echo -ne "                                                                                                    \r"
  echo -e "${dred}##|${red}${RX_leng}\t${orange}##|${yellow}${TX_leng}\t${dgreen}Time:${green}${TIME_pretty}${NC}"
done
exit 0
## I've never run that fast! -- cit.
